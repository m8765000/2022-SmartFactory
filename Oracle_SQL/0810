EMP 테이블 & DEPT테이블 두개를 JOIN해서 다음 컬럼을 출력해 주세요.
----------------------------------------------------------------------------
컬럼
#1 등가조인 기본
EMPNO, ENAME, DEPTNO, DANME, LOC 출려개 주세요.
-----------------------------------------------------------------------------
#2 등가조인 조건
출력해야될 컬럼은 #1과 같고 급여가 2500이하이고 사원번호가 9999이하인 
사원 정보를 출력해 주세요.
-----------------------------------------------------------------------------
#3 비등가 조인
EMP테이블과 SALGRADE 테이블을 비등가 조인하여 급여범위를 출력해 주세요
컬럼은 모두(*) 출력하겠습니다.
--------------------------------------------------------------------------------
#4 자체조인
EMP 테이블을 자체조인하여 사원의 매니저번호가 출력되도록 해주세요.
출력컬럼
E1.EMPNO, E1.ENAME, E1.MGR, 
E2.EMPNO, E2.ENAME
-------------------------------------------------------------------------
#5 외부조인
문제#4를 풀어보면 사장인 KING은 MGR이 없어 등가조인으로는 
출력이 되지 않습니다. OUTER JOIN(외부조인)을 사용하여 KING도
출력을 해주세요.
단, KING의 데이터만 있으면 됩니다. Left, Right 여부는 여러분이 판단해주세요.

#1
SELECT  E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;
#2
SELECT  E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND
E.SAL <=2500 AND E.EMPNO <=9999;
#3
SELECT * FROM EMP E, SALGRADE S
WHERE SAL BETWEEN S.LOSAL AND S.HISAL;
#4
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO, E2.ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;
#5
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO, E2.ENAME
FROM EMP E1, EMP E2
WHERE E1.EMPNO = E2.MGR(+);
#SQL-99
#8-11 NATURAL JOIN등가조인
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM
       DEPTNO, D.DNAME, D.LOC
FROM EMP E NATURAL JOIN DEPT D
ORDER BY DEPTNO, E.EMPNO;

#9-13 30번 부서 사원들의 최소 급여보다 많은 급여를 받는 사원 정보 출력
#1
SELECT SAL FROM EMP WHERE DEPTNO =30;
#2 
SELECT * FROM EMP
WHERE SAL > ANY(SELECT SAL FROM EMP WHERE DEPTNO =30);
#9-14 30번 부서 사원들의 최소 급여보다 더 적은 급여를 받는 사원 정보 출력 (>하면 최대급여 보다)
SELECT * FROM EMP
WHERE SAL < ALL(SELECT SAL FROM EMP WHERE DEPTNO =30);
#9-16 EXISTS 존재하면 TRUE 실행
#1
SELECT DNAME FROM DEPT WHERE DEPTNO=10;
#2
SELECT * FROM EMP WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO=10);

#9-4 다중열 서브쿼리 (**)
#1
SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO;
#2
SELECT * FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);

#9-5 인라인 뷰(INLINE VIEW) ==> FROM 절에서 사용하는 서브쿼리
SELECT E10.EMPNO, E10.ENAME, E10.DEPTNO, D.DNAME, D.LOC
FROM (SELECT * FROM EMP WHERE DEPTNO = 10) E10,
     (SELECT * FROM DEPT) D
WHERE E10.DEPTNO = D.DEPTNO;

#WITH 절 사용하기
#테이블 내 데이터 규모가 너무 크거나 현재작업에서 불 필요한 컬럼이 많아서 일부
#행과 열만 사용하고자 할때, E10을 새 테이블처럼 사용한다
WITH
E10 AS (SELECT * FROM EMP WHERE DEPTNO = 10),
D   AS (SELECT * FROM DEPT)
SELECT E10.EMPNO, E10.ENAME, E10.DEPTNO, D.DNAME, D.LOC FROM E10, D
WHERE E10.DEPTNO = D.DEPTNO;

#SELECT절에서 서브쿼리 사용가능
#1
SELECT GRADE FROM SALGRADE;
#2
SELECT EMPNO, ENAME, JOB, SAL,
       (SELECT GRADE FROM SALGRADE WHERE E.SAL BETWEEN LOSAL AND HISAL),
        DEPTNO,
        (SELECT DNAME FROM DEPT WHERE E.DEPTNO = DEPT.DEPTNO)
FROM EMP E;

#테이블 조작어
DROP TABLE DEPT_TEMP;

CREATE TABLE DEPT_TEMP
 AS SELECT * FROM  DEPT;

SELECT * FROM DEPT_TEMP;
#삭제
DELETE FROM DEPT_TEMP WHERE DEPTNO=50;
#삽입
INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
VALUES (50, 'DATABASE', 'SEOUL');

INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
VALUES (70, 'WEB', NULL);

DROP TABLE EMP_TEMP;
#테이블 구조만 복사
CREATE TABLE EMP_TEMP
AS SELECT * FROM EMP WHERE 1 <> 1;

SELECT * FROM EMP_TEMP;

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
                    VALUES(1111, '성춘향', 'MANAGER', 9999, '2001-01-05', 4000, NULL, 20);

#10-12
INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (1111, '이순신', 'MANAGER', 9999, TO_DATE('07/01/2001', 'DD/MM/YYYY'),
        4000, NULL, 20);
       
#TALBLE DEPT_TEMP2 만들기
CREATE TABLE DEPT_TEMP2
AS SELECT * FROM DEPT;

SELECT * FROM DEPT_TEMP2;
#UPDATE는 항상 조심해야한다 아래 처럼하면 4개의 행이 SEOUL로 UPDATE된다.
UPDATE DEPT_TEMP2 SET LOC = 'SEOUL';

UPDATE DEPT_TEMP2 SET LOC = 'SEOUL'
WHERE DEPTNO = 10;

ROLLBACK;
COMMIT;

#10-18
#하나 이상의 데이터를 수정해봅시다.
UPDATE DEPT_TEMP2
    SET DNAME = 'DATABASE',
        LOC = 'SEOUL'
WHERE DEPTNO = 40;

SELECT * FROM DEPT_TEMP2;

#급여가 $2500 이상인 사원은 추가수당 (COMM)을 $50으로 수정해 주세요. EMP_TEMP
UPDATE EMP_TEMP
    SET COMM = 50
WHERE SAL >= 2500;
SELECT * FROM EMP_TEMP;

#10-19
SELECT DNAME, LOC FROM DEPT WHERE DEPTNO = 40;
UPDATE DEPT_TEMP2
    SET (DNAME, LOC) = (SELECT DNAME, LOC FROM DEPT WHERE DEPTNO = 40)
WHERE DEPTNO = 40;

SELECT * FROM DEPT_TEMP2;

#P287
CREATE TABLE CHAP10HW_EMP AS SELECT * FROM EMP;
CREATE TABLE CHAP10HW_DEPT AS SELECT * FROM DEPT;
CREATE TABLE CHAP10HW_SALGRADE AS SELECT * FROM SALGRADE;
SELECT * FROM CHAP10HW_DEPT;
INSERT INTO CHAP10HW_DEPT (DEPTNO, DNAME, LOC)
VALUES (50, 'ORACLE', 'BUSAN');

INSERT INTO CHAP10HW_DEPT (DEPTNO, DNAME, LOC)
VALUES (60, 'SQL', 'ILSAN');

INSERT INTO CHAP10HW_DEPT (DEPTNO, DNAME, LOC)
VALUES (70, 'SELECT', 'INCHEON');

INSERT INTO CHAP10HW_DEPT (DEPTNO, DNAME, LOC)
VALUES (80, 'DML', 'BUNDANG');

INSERT INTO CHAP10HW_EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (7201, 'TEST_USER1', 'MANAGER', 7788, TO_DATE('2016-01-02', 'YYYY-MM-DD'),4500 , NULL,
50);

INSERT INTO CHAP10HW_EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (7202, 'TEST_USER2', 'SALESMAN', 7201, TO_DATE('2016-05-31', 'YYYY-MM-DD'),2700 , 300,
60);
SELECT * FROM CHAP10HW_EMP
ORDER BY DEPTNO;
COMMIT;
UPDATE CHAP10HW_EMP
    SET DEPTNO = 70
WHERE SAL >= (SELECT AVG(SAL) FROM CHAP10HW_EMP WHERE DEPTNO = 50);

UPDATE CHAP10HW_EMP
    SET DEPTNO =80, SAL = SAL * 1.1
WHERE HIREDATE > (SELECT MIN(HIREDATE) FROM CHAP10HW_EMP WHERE DEPTNO = 60);

SELECT * FROM CHAP10HW_EMP;

#11 장 트랜잭션
#DEPT ==> DEPT_TCML
CREATE TABLE DEPT_TCL
    AS SELECT * FROM DEPT;

SELECT * FROM DEPT_TCL;

#삽입
INSERT INTO DEPT_TCL VALUES ( 50, 'DATABASE', 'SEOUL');
#수정
UPDATE DEPT_TCL SET LOC = 'BUSAN' WHERE DEPTNO = 40;
#삭제
DELETE FROM DEPT_TCL WHERE DNAME='RESEARCH';
#검색
SELECT * FROM DEPT_TCL;

#ROLLBACK
ROLLBACK;

#12장 데이터 정의어
#12-1
CREATE TABLE EMP_DDL(
    EMPNO        NUMBER(4),
    ENAME        VARCHAR(10),
    JOB          VARCHAR(9),
    MGR          NUMBER(4),
    HIREDATE     DATE,
    SAL          NUMBER(7,2),
    COMM         NUMBER(7,2),
    DEPTNO       NUMBER(2)
);

SELECT * FROM EMP_DDL;
#12-4 테이블의 부분만 복사하여 새 테이블 만들기
CREATE TABLE EMP_DDL_30
    AS SELECT * FROM EMP
        WHERE DEPTNO =30;
        
#테이블을 변경하는 ALTER
CREATE TABLE EMP_ALTER AS SELECT * FROM EMP;

#열(컬럼)을 추가해 봅시다. VARCHAR2가 더 효율적이라서 사용
ALTER TABLE EMP_ALTER
 ADD HP VARCHAR2(20);
 
 #HP ---> TEL RENAME COLUMN A TO B 통으로 외우기
 #RENAME COLMN
 ALTER TABLE EMP_ALTER
    RENAME COLUMN HP TO TEL;
    
SELECT * FROM EMP_ALTER;
#COMM ==> BONUS
ALTER TABLE EMP_ALTER
    RENAME COLUMN COMM TO BONUS;
    
#컬럼의 자료형 변경==> 컬럼의 형변환
#MODIFY
DESC EMP_ALTER;
ALTER TABLE EMP_ALTER
MODIFY EMPNO NUMBER(5);

ALTER TABLE EMP_ALTER
DROP COLUMN TEL;

SELECT * FROM EMP_ALTER;

#테이블 이름변경 RENAME
#RENAME A TO B
RENAME EMP_ALTER TO EMP_RENAME;

#테이블 구조만 남기고 전체 데이터 삭제
#TRUNCATE TABLE
TRUNCATE TABLE EMP_RENAME;
SELECT * FROM EMP_RENAME;

DESC EMP_RENAME;

ALTER TABLE EMP_RENAME
MODIFY EMPNO NUMBER(4);

#P324
CREATE TABLE EMP_HW (
    EMPNO         NUMBER(4),
    ENAME         VARCHAR(10),
    JOB           NUMBER(9),
    MGR           NUMBER(4),
    HIREDATE      DATE,
    SAL           NUMBER(7,2),
    COMM          NUMBER(7,2),
    DEPTNO        NUMBER(2));
    
ALTER TABLE EMP_HW 
    ADD BIGO VARCHAR(20);
    
ALTER TABLE EMP_HW
MODIFY BIGO VARCHAR(30);

ALTER TABLE EMP_HW
RENAME COLUMN BIGO TO REMARK;

SELECT * FROM EMP_HW;

INSERT INTO EMP_HW 
    SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, NULL 
FROM EMP;

DROP TABLE EMP_HW;

# 규칙에 맞는 순번을 생성하는 작업 ==> 시퀀스
#13-26
#DEPT 테이블을 사용하여 DEPT_SEQUENCE 테이블

CREATE TABLE DEPT_SEQUENCE
 AS SELECT * FROM DEPT WHERE 1<>1;
 
SELECT * FROM DEPT_SEQUENCE;

#SEQUENCE 만들기
CREATE SEQUENCE SEQ_DEPT_SEQUENCE
  INCREMENT BY 10
  START WITH 10
  MAXVALUE 90
  MINVALUE 0
  CACHE 2;
  
#생성한 시퀀스를 쿼리로 확인하기
SELECT * FROM USER_SEQUENCES;

#13-29 시퀀스를 이용한 데이터 삽입
INSERT INTO DEPT_SEQUENCE (DEPTNO, DNAME, LOC)
VALUES (SEQ_DEPT_SEQUENCE.NEXTVAL, 'DATABASE', 'SEOUL');

SELECT * FROM DEPT_SEQUENCE ORDER BY DEPTNO;

#가장 마지막으로 생성된 시퀀스번호 확인하기
SELECT SEQ_DEPT_SEQUENCE.CURRVAL FROM DUAL;

#13-32 시퀀스 옵션 수정
ALTER SEQUENCE SEQ_DEPT_SEQUENCE
    INCREMENT BY 3
    MAXVALUE 99
    CYCLE;
#13-13 시퀀스 수정
SELECT * FROM USER_SEQUENCES;

#시퀀스 삭제
DROP SEQUENCE SEQ_DEPT_SEQUENCE;

SELECT * FROM TAB;

#hr 계정에 권한을 부여
GRANT CREATE SYNONYM TO HR;
GRANT CREATE PUBLIC SYNONYM TO HR;

#동의어 생성
#EMP 테이블 동의어 생성
CREATE SYNONYM E FOR EMP;
기본적인 SQL 이후에하는것 데이터 중심의 설계 제약조건 
#제약 
#UNIQUE, PRIMARY KEY, FOREIGN KEY
CREATE TABLE TABLE_NOTNULL(
    LOGIN_ID VARCHAR2(20) NOT NULL,
    LOGIN_PWD VARCHAR2(20) NOT NULL,
    TEL       VARCHAR2(20)
);

SELECT * FROM TABLE_NOTNULL;
#14-2
INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01', NULL, '010-1234-5678');

#14-3
INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PWD)
VALUES('TEST_ID_01', '1234');

#14-4 NOT NULL 제약조건이 지정된 열 데이터를 NULL값으로 업데이트
UPDATE TABLE_NOTNULL
SET LOGIN_PWD = NULL
WHERE LOGIN_ID = 'TEST_ID_01';
