#SQL 일반함수
#숫자 데이터
SELECT ROUND(1234.5678),
       ROUND(1234.5678, 0),
       ROUND(1234.5678, 1),
       ROUND(1234.6578, 2),
       ROUND(1234.6578, 3)
from dual;

SELECT TRUNC(1234.5678, 1),
       TRUNC(1234.5678, 2),
       TRUNC(1234.5678, 3)
FROM DUAL;

#지정된 숫자와 가까운 점수를 찾는 함수 CEIL(올림), FLOOR(내림)
SELECT CEIL(3.14),
       FLOOR(3.14),
       CEIL(-3.14),
       FLOOR(-3.14)
FROM DUAL;

#나누셈 %
SELECT MOD(15, 6),
       MOD(10, 2),
       MOD(11, 2)
FROM DUAL;

#날짜
SELECT SYSDATE,
       SYSDATE-1 AS "어제",
       SYSDATE+1 AS 내일
FROM DUAL;

#3개월 후 날짜 구하기
SELECT SYSDATE, ADD_MONTHS(SYSDATE, 3) FROM DUAL;

#입사 10주년이 되는 사원들 데이터 출력하기
SELECT EMPNO, ENAME, HIREDATE,
       ADD_MONTHS(HIREDATE, 120) AS WORK10YEAR
FROM EMP;

#입사 32년 미만인 사원 데이터 출력하기 --> WHERE 사용
SELECT EMPNO, ENAME, HIREDATE,SYSDATE FROM EMP 
WHERE ADD_MONTHS(HIREDATE, 450) > SYSDATE;

#SYSDATE와 ADD_MONTHS 함수를 사용해서 현재 날짜와 6개월 후 날짜를 출력해 봅시다.
SELECT SYSDATE, ADD_MONTHS(SYSDATE, 6) FROM DUAL;

#두 날짜간의 개월 수 차이를 구하는 함수 MONTHS_BETWEEN
SELECT EMPNO, ENAME, HIREDATE, SYSDATE,
       TRUNC( MONTHS_BETWEEN(HIREDATE, SYSDATE)) AS MONTHS1,
       TRUNC(MONTHS_BETWEEN(SYSDATE, HIREDATE)) AS MONTHS2
FROM EMP;

#돌아오는 요일, 달의 마지막 날짜 NEXT_DAY(날짜 데이터, 요일 문자), LAST_DAY
SELECT SYSDATE,
       NEXT_DAY(SYSDATE, '수요일'),
       LAST_DAY('22/02/05')
FROM DUAL;

#날짜 ROUND 함수 P155
SELECT SYSDATE,
       ROUND(SYSDATE, 'CC'),
       ROUND(SYSDATE, 'YYYY'),
       ROUND(SYSDATE, 'Q'),
       ROUND(SYSDATE,'DDD'),
       ROUND(SYSDATE, 'HH')
FROM DUAL;

SELECT SYSDATE,
       TRUNC(SYSDATE, 'CC'),
       TRUNC(SYSDATE, 'YYYY'),
       TRUNC(SYSDATE, 'Q'),
       TRUNC(SYSDATE,'DDD'),
       TRUNC(SYSDATE, 'HH')
FROM DUAL;

#자료형(TYPE)을 변환하는 변환함수
SELECT EMPNO, ENAME, EMPNO + '500' 
FROM EMP WHERE ENAME = UPPER('SCOTT');

#문자열과 숫자 더하기
#SELECT 'ABCD' + empno from emp;  #Error
#SUBSTR()
#TO_CHAR() 응용이 가능한 메소드 중요하다
#날짜 형식 패턴을 이용하여 출력가능
SELECT TO_CHAR(SYSDATE, 'YYYY/MM/DD HH24:MI:SS') AS 현재날짜시간 FROM DUAL;

#여러 언어로 날짜(월) 출력
SELECT SYSDATE,
       TO_CHAR(SYSDATE, 'MM') AS MM,
       TO_CHAR(SYSDATE, 'MON', 'NLS_DATE_LANGUAGE = ENGLISH') AS English, 
       TO_CHAR(SYSDATE, 'MON', 'NLS_DATE_LANGUAGE = JAPANESE') AS Japanese,
       TO_CHAR(SYSDATE, 'MON', 'NLS_DATE_LANGUAGE = KOREAN') AS Japanese
FROM DUAL;

#SYSDATE 시간 형식 지정하여 출력
SELECT SYSDATE, TO_CHAR(SYSDATE, 'HH24:MI:SS PM') FROM DUAL;

#숫자형식을 TO_CHAR로 표현해 봅시다.
SELECT SAL,
       TO_CHAR(SAL, '$999,999')AS SAL1,
       TO_CHAR(SAL, 'L999,999') AS SAL2,
       TO_CHAR(SAL, '999,999.00') AS SAL3
FROM EMP;

#TO_NUMBER 문자데이터를 숫자데이터로
SELECT '1300' - '1500',
       '1300' + '1500'
FROM DUAL;

SELECT TO_NUMBER( '888,888', '999,999' ) - TO_NUMBER('333,333', '999,999' ) FROM DUAL;
#문자 데이터를 날짜 데이터로 변환 TO_DATE
SELECT TO_DATE('2018-07-04', 'YYYY-MM-DD'),
       TO_DATE('20180704', 'YYYY-MM-DD')
FROM DUAL;

#1981년 6월 1일 이후에 입사한 사원 정보를 출력해 봅시다!!!!
SELECT * 
    FROM EMP 
    WHERE HIREDATE > TO_DATE ('1981/06/01', 'YYYY/DD/MM');

#DB NULL처리 NVL 함수 중요***
#데이터가 NULL이 아니면 그대로 반환, NULL이라면 여러분이 지정한 값으로 변환
SELECT EMPNO, ENAME, SAL, COMM, SAL + COMM,
       NVL(COMM, 0),
       SAL+NVL(COMM, 0)
FROM EMP;

#NVL2함수 지정값이 추가 #3항 연산자 와 비슷함
SELECT COMM, NVL2(COMM, 'O', 'X'),
       NVL2(COMM, SAL*12+COMM, SAL*12)
FROM EMP;

###DECODE 응용 부분
SELECT EMPNO, ENAME, JOB, SAL,
       DECODE(JOB,
                'MANAGER' , SAL*1.1,
                'SALESMAN', SAL * 1.05,
                'ANALYST', SAL,
                SAL*1.03) AS 급여 
FROM EMP;

# 6-49
SELECT EMPNO, ENAME, COMM,
    CASE
     WHEN COMM IS NULL THEN '해당사항 없음'
     WHEN COMM = 0 THEN '수당없음'
     WHEN COMM > 0 THEN '수당 : ' || COMM
     END AS COMM_TEXT
FROM EMP;

#1. EMPNO 열에는 EMP 테이블에서 사원이름(ENAME)이 다섯글자 이상이며 여섯 글자 미만인 사원정보를
출력합니다. MASKING_EMPNO 열에는 사원번호(EMPNO) 앞 두 자리 외 뒷자리를 * 기호로 출력합니다
그리고 MASKING_ENAME 열에는 사원이름의 첫글 자만 보여주고 나머지 글자 수만큼 *기호로 출력하세요
SELECT EMPNO,
    RPAD(SUBSTR(EMPNO,0,2),4, '*') AS MASKING_EMPNO,
    ENAME,
    RPAD(SUBSTR(ENAME,0,1),5, '*') AS MASKING_ENAME
FROM EMP;
#2. EMP 테이블에서 사원들의 월 평균 근무일 수는 21.5일 입니ㅏㄷ. 하루근무 시간을 8시간으로 보았을 때
사원들의 하루급여(DAY_PAY)와 시급(TIME_PAY)을 계산하여 결과를 출력합니다 단 하루 급여는 소수점
세번째 자리에서 버리고, 시급은 두 번째 소수점에서 반올림하세요
SELECT EMPNO, ENAME, SAL,
    TRUNC(SAL / 21.5, 2) AS DAY_PAY,
    ROUND(SAL / 21.5 / 8, 1) AS TIME_PAY
FROM EMP;
#3. EMP 테이블에서 사원들은 입사일(HIREDATE)을 기준으로 3개월이 지난 후 첫 월요일에 정직원이 됩니다.
사원들이 정직원이 되는 날짜(R_JOB)를 YYYY-MM-DD 형식으로 오른쪽과 같이 출력해 주세요. 단, 추가 수당
(COMM)이 없는 사원의 추가 수당은 N/A로 출력하세요.
SELECT EMPNO, ENAME, HIREDATE,
    TO_CHAR(NEXT_DAY(ADD_MONTHS(HIREDATE, 3), '월요일'),  'YYYY-MM-DD') AS R_JOB,
    NVL(TO_CHAR(COMM), 'N/A') AS COMM
FROM EMP;
#4. EMP 테이블의 모든 사원을 대상으로 직속 상관의 사원번호(MGR)를 다음과 같은 조건을 기준으로 변환해서
CHG_MGR열에 출력하세요
직속상관의 사원번호가 존재하지않을 경우 0000
직속상관의 사원번호 앞 두자리가 75일 경우 5555
그외 직속 상관 사원 번호의 경우 : 본래 직속 상관의 사원번호그대로 출력
SELECT EMPNO, ENAME, MGR,
    CASE
        WHEN MGR IS NULL THEN '0000'
        WHEN SUBSTR(MGR, 1, 2) = '75' THEN '5555'
        WHEN SUBSTR(MGR, 1, 2) = '76' THEN '6666'
        WHEN SUBSTR(MGR, 1, 2) = '77' THEN '7777'
        WHEN SUBSTR(MGR, 1, 2) = '78' THEN '8888'
        ELSE TO_CHAR(MGR)
        END AS CHG_MGR
FROM EMP;

#다중행 함수, 데이터 그룹화
#COUNT, SUM, AVG, MAX, MIN
SELECT SUM(SAL) FROM EMP;
SELECT COUNT(SAL) FROM EMP;
#다중행 함수와 단일행 함수를 같이 쓰면 에러가 발생한다.
SELECT ROUND(AVG(SAL),2) FROM EMP;

#급여 합계 구하기
SELECT SUM(DISTINCT SAL),
       SUM(ALL SAL),
       SUM(SAL)
FROM EMP;

#부서번호
SELECT COUNT(*) FROM EMP
WHERE DEPTNO = 30;

#최댓값 최솟값
SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 10;
SELECT MIN(SAL) FROM EMP WHERE DEPTNO = 10;

#입사일이 가장 최신일 출력 부서번호가 20번
SELECT MAX(HIREDATE) FROM EMP 
WHERE DEPTNO = 20;

#GROUP BY 결과값을 원하는 열로 묶어 출력
SELECT ROUND(AVG(SAL),2), DEPTNO FROM EMP
GROUP BY DEPTNO;

#부서번호 및 직책별 평균 급여 계산하기
SELECT DEPTNO, JOB, AVG(SAL) FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

#GROUP BY 절에서 조건(WHERE) 검색
SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >= 2000;

#WHERE과 HAVING이 같이 사용가능한가??
#7-23
SELECT DEPTNO, JOB, AVG(SAL) FROM EMP
WHERE SAL <=3000
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >=2000
ORDER BY DEPTNO, JOB;

#다중형 함수, 데이터 그룹화
#COUNT, SUM, AVG, MAX, MIN (다중행 함수)
#GROUP BY(그룹화)
#HAVING (조건)

#직업별(JOB) 연봉
#부서별(DEPT) 연봉 기타 데이터
#직별 테이블(JOBS)
SELECT JOB, TRUNC(AVG(SAL),0) 연봉 FROM EMP
GROUP BY JOB;

SELECT DEPTNO, JOB, TRUNC(AVG(SAL), 0) FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >=2000
ORDER BY DEPTNO;

SELECT COUNT(DISTINCT JOB) FROM EMP;
SELECT JOB FROM EMP;

SELECT COUNT(*), ROUND(AVG(SAL), 2), DEPTNO FROM EMP
GROUP BY DEPTNO
HAVING AVG(SAL) > 1800
ORDER BY DEPTNO;

#다양한 그룹화 함수들
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL) 
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO;

SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL) 
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB);

SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL) 
FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

#DEPTNO를 먼저 그룹화한 후 ROLLUP 함수에 JOB 지정하기
SELECT DEPTNO, JOB, COUNT(*) FROM EMP
GROUP BY DEPTNO, ROLLUP(JOB);

#JOB을 먼저 그룹화한 후 ROLLUP 함수에 DEPTNO 지정하기
SELECT DEPTNO, JOB, COUNT(*) FROM EMP
GROUP BY JOB, ROLLUP(DEPTNO);

#p201
#GROUPTIN SET
#컬럼별 그룹화를 통해 결과를 출력함
SELECT DEPTNO, JOB, COUNT(*) FROM EMP
GROUP BY GROUPING SETS(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

#7-30 DEPTNO, JOB 열의 그룹화 결과 여부를 GROUPING 함수로 확인해 봅시다.
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL),
        GROUPING(DEPTNO),
        GROUPING(JOB)
    FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;

#7-31
SELECT DECODE(GROUPING(DEPTNO), 1, 'ALL_DEPT', DEPTNO) AS DEPTNO,
       DECODE(GROUPING(JOB), 1, 'ALL_JOB', JOB) AS JOB,
       COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
    FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY DEPTNO, JOB;
#7-32 GROUPING_ID

#LISTAGG 함수 오라클 11g 지원
#그룹에 속해있는 데이터를 가로로 나열하기 위해
SELECT DEPTNO,
       LISTAGG(ENAME, ',')
       WITHIN GROUP(ORDER BY SAL DESC) AS ENAMES
FROM EMP
GROUP BY DEPTNO;

#실력을 업그레이드 해주는 함수
#PIVOT, UNPIVOT
SELECT DEPTNO, JOB, MAX(SAL)
       FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;
#행과 열을 뒤집는다.
SELECT * FROM (SELECT DEPTNO, JOB, SAL 
         FROM EMP)
PIVOT(MAX(SAL)
      FOR DEPTNO IN (10, 20, 30)
      )
ORDER BY JOB;

#7-37
#PIVOT 함수를 사용하여 부서별, 직책별 최고 급여를 2차원 표 형태로 출력하기
SELECT *
    FROM(SELECT JOB, DEPTNO, SAL
         FROM EMP)
PIVOT(MAX(SAL)
      FOR JOB IN ('CLERK' AS CLERK,
      'SALESMAN' AS SALESMAN,
      'PRESIDENT' AS PRESIDENT,
      'MANAGER' AS MANAGER,
      'ANALYST' AS ANALYST
    ))
ORDER BY DEPTNO;

#DECODE문을 활용하여 PIVOT 구현
SELECT DEPTNO,
    MAX(DECODE(JOB, 'CLERK', SAL)) AS 점원,
    MAX(DECODE(JOB, 'SALESMAN', SAL)) AS 판매원
FROM EMP
GROUP BY DEPTNO;

#1
SELECT DEPTNO, TRUNC(AVG(SAL)) AS AVG_SAL, MAX(SAL) AS MAX_SAL, MIN(SAL) AS MIN_SAL, COUNT(*) AS CNT FROM EMP
GROUP BY DEPTNO;

#2
SELECT JOB, COUNT(*) FROM EMP
GROUP BY JOB
HAVING COUNT(*) > 2;

#3
SELECT TO_CHAR(HIREDATE, 'YYYY'), DEPTNO, COUNT(*)
FROM EMP
GROUP BY TO_CHAR(HIREDATE, 'YYYY'), DEPTNO;

#4
SELECT NVL2(COMM, 'O', 'X'), COUNT(*)
FROM EMP
GROUP BY NVL2(COMM, 'O', 'X');

#5
SELECT DEPTNO,
       TRUNC(AVG(SAL)) AS AVG_SAL,
       MAX(SAL) AS MAX_SAL,
       MIN(SAL) AS MIN_SAL,
       SUM(SAL) AS SUM_SAL,
       COUNT(*) AS CNT FROM EMP
GROUP BY ROLLUP(DEPTNO, TO_CHAR(HIREDATE, 'YYYY'));
